#!/usr/bin/python
#    autotrash.py - GNOME GVFS Trash old file auto prune
#    
#    Copyright (C) 2008 A. Bram Neijt <bneijt@gmail.com>
#    
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import optparse
import ConfigParser
import shutil
import glob
import os
import time
import math
import logging

# custom logging level between DEBUG and INFO
VERBOSE = 15

def real_file_name(trash_name):
  '''Get real file name from trashinfo file name: basename without extension in ../files'''
  basename = os.path.basename(trash_name)
  trash_directory = os.path.abspath(os.path.join(os.path.dirname(trash_name), '..'))
  (file_name, trashinfo_ext) = os.path.splitext(basename)
  return os.path.join(trash_directory, 'files', file_name)

def purge(trash_directory, trash_name, dryrun):
  '''Purge the file behind the trash file fname'''
  target = real_file_name(trash_name)
  if dryrun:
    if os.path.exists(target):
      logging.info(' Remove  %s', target)
    else:
      logging.info('[Remove] %s', target)
    if os.path.exists(trash_name):
      logging.info(' Remove  %s', trash_name)
    else:
      logging.info('[Remove] %s', trash_name)
    return False
  #The real deleting...
  if os.path.exists(target):
    if os.path.isdir(target) and not os.path.islink(target):
      logging.log(VERBOSE, 'Removing directory %s', target)
      shutil.rmtree(target)
    else:
      logging.log(VERBOSE, 'Removing file %s', target)
      os.unlink(target)
  os.unlink(trash_name)
  return True

def trash_info_date(fname):
  parser = ConfigParser.SafeConfigParser()
  readCorrectly = parser.read(fname)
  section = 'Trash Info'
  key = 'DeletionDate'
  if readCorrectly.count(fname) and parser.has_option(section, key):
    #Read the file succesfully
    return time.strptime(parser.get(section, key), '%Y-%m-%dT%H:%M:%S')
  return None

def main(args):
  #Load and set configuration options
  parser = optparse.OptionParser(usage='%prog')
  parser.set_defaults(
      days = 30,
      trash_path = os.path.join('~','.local','share','Trash'),
      verbose = False,
      quiet = False,
      check = False,
      dryrun = False,
      )
  parser.add_option('-d', '--days', dest='days', type='int', help='Delete files older then DAYS number of days. Default: %i' % parser.defaults['days'], metavar='DAYS')
  parser.add_option('-T', '--trash-path', dest='trash_path', help='Set Trash path to PATH. Default: %s' % parser.defaults['trash_path'], metavar='PATH')
  parser.add_option('-v', '--verbose', action='store_true', dest='verbose', help='Be more verbose, a must when testing something out')
  parser.add_option('-q', '--quiet', action='store_true', dest='quiet', help='Only output warnings (is overruled by verbose)')
  parser.add_option('--check', action='store_true', dest='check', help='Report .trashinfo files without a real file')
  parser.add_option('--dry-run', action='store_true', dest='dryrun', help='Just list what would have been done')
  parser.add_option('-V', '--version', action='store_true', dest='version', help='Show version and exit')
  (options, args) = parser.parse_args()
  
  if options.version:
    print '''Version 0.0.5SVN \nCopyright (C) 2008 A. Bram Neijt <bneijt@gmail.com>\n License GPLv3+'''
    return 1
  
  if options.days <= 0:
    parser.error('Can not work with negative or zero days')
    return 1

  logging.basicConfig(level=logging.INFO, format='%(message)s')
  logging.addLevelName(VERBOSE, 'VERBOSE')
  if options.verbose:
    logging.getLogger().setLevel(VERBOSE)
  elif options.quiet:
    logging.getLogger().setLevel(logging.WARNING)
  
  trash_info_path = os.path.expanduser(os.path.join(options.trash_path,'info'))
  if not os.path.exists(trash_info_path):
    logging.error('Can not find trash information directory. Make sure you have at least GNOME 2.24')
    logging.error('I was looking at: %s', trash_info_path)
    return 1
  for file_name in glob.iglob(os.path.join(trash_info_path, '*.trashinfo')):
    if options.check:
      if not os.path.exists(real_file_name(file_name)):
        logging.warning('%s has no real file associated with it.', file_name)
    file_time = trash_info_date(file_name)
    if file_time == None:
      continue
    #Calculate seconds from now
    seconds_old = time.time() - time.mktime(file_time)
    days_old = int(math.floor(seconds_old/(3600.0*24.0)))
    logging.log(VERBOSE, 'File %s', file_name)
    logging.log(VERBOSE, '  is %d days old, %d seconds', days_old, seconds_old)
    logging.log(VERBOSE, '  deletion date was %s', time.strftime('%c', file_time))
    if days_old > options.days:
      purge(options.trash_path, file_name, options.dryrun)
      if options.dryrun:
        logging.info('  because it describes a %d days old file', days_old)
  return 0

if __name__ == '__main__':
  sys.exit(main(sys.argv))
