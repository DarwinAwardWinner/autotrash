#!/usr/bin/python
#    autotrash.py - GNOME GVFS Trash old file auto prune
#    
#    Copyright (C) 2008 A. Bram Neijt <bneijt@gmail.com>
#    
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import optparse
import ConfigParser
import shutil
import glob
import os
import time
import math
import logging

# custom logging level between DEBUG and INFO
VERBOSE = 15

def real_file_name(trash_name):
  '''Get real file name from trashinfo file name: basename without extension in ../files'''
  basename = os.path.basename(trash_name)
  trash_directory = os.path.abspath(os.path.join(os.path.dirname(trash_name), '..'))
  (file_name, trashinfo_ext) = os.path.splitext(basename)
  return os.path.join(trash_directory, 'files', file_name)

def purge(trash_directory, trash_name, dryrun):
  '''Purge the file behind the trash file fname'''
  target = real_file_name(trash_name)
  if dryrun:
    if os.path.exists(target):
      logging.info(' Remove  %s', target)
    else:
      logging.info('[Remove] %s', target)
    if os.path.exists(trash_name):
      logging.info(' Remove  %s', trash_name)
    else:
      logging.info('[Remove] %s', trash_name)
    return False
  #The real deleting...
  if os.path.exists(target):
    if os.path.isdir(target) and not os.path.islink(target):
      logging.log(VERBOSE, 'Removing directory %s', target)
      shutil.rmtree(target)
    else:
      logging.log(VERBOSE, 'Removing file %s', target)
      os.unlink(target)
  os.unlink(trash_name)
  return True

def trash_info_date(fname):
  parser = ConfigParser.SafeConfigParser()
  readCorrectly = parser.read(fname)
  section = 'Trash Info'
  key = 'DeletionDate'
  if readCorrectly.count(fname) and parser.has_option(section, key):
    #Read the file succesfully
    return time.strptime(parser.get(section, key), '%Y-%m-%dT%H:%M:%S')
  return None

def get_consumed_size(path):
  '''Get the amount of filesystem space actually consumed by a file or directory'''
  size = 0
  try:
    if os.path.islink(path):
      size = os.lstat(path).st_size
    else:
      size = os.stat(path).st_blocks * 512
      if os.path.isdir(path):
        for entry_name in os.listdir(path):
          size += get_consumed_size(os.path.join(path, entry_name))
  except OSError:
    logging.error('Error getting size for %s', path)
  return size

def fmt_bytes(bytes, fmt='%.1f'):
  for pow, name in  (40, 'TiB'), (30, 'GiB'), (20, 'MiB'), (10, 'KiB'):
    if bytes >= 2**pow:
      return '%s %s' % (fmt % (1. * bytes / 2**pow,), name)
  return '%d bytes' % bytes

def main(args):
  #Load and set configuration options
  parser = optparse.OptionParser(usage='%prog')
  parser.set_defaults(
      days = 30,
      trash_path = os.path.join('~','.local','share','Trash'),
      verbose = False,
      quiet = False,
      check = False,
      stat = False,
      dryrun = False,
      )
  parser.add_option('-d', '--days', dest='days', type='int', help='Delete files older then DAYS number of days. Default: %i' % parser.defaults['days'], metavar='DAYS')
  parser.add_option('-T', '--trash-path', dest='trash_path', help='Set Trash path to PATH. Default: %s' % parser.defaults['trash_path'], metavar='PATH')
  parser.add_option('-v', '--verbose', action='store_true', dest='verbose', help='Be more verbose, a must when testing something out')
  parser.add_option('-q', '--quiet', action='store_true', dest='quiet', help='Only output warnings (is overruled by verbose)')
  parser.add_option('--check', action='store_true', dest='check', help='Report .trashinfo files without a real file')
  parser.add_option('--dry-run', action='store_true', dest='dryrun', help='Just list what would have been done')
  parser.add_option('--stat', action='store_true', dest='stat', help='Calculate the number and total size of files involved')
  parser.add_option('-V', '--version', action='store_true', dest='version', help='Show version and exit')
  (options, args) = parser.parse_args()
  
  logging.basicConfig(level=logging.INFO, format='%(message)s')
  logging.addLevelName(VERBOSE, 'VERBOSE')
  if options.verbose:
    logging.getLogger().setLevel(VERBOSE)
  elif options.quiet:
    logging.getLogger().setLevel(logging.WARNING)

  if options.version:
    logging.info('''Version 0.0.5SVN\nCopyright (C) 2008 A. Bram Neijt <bneijt@gmail.com>\nLicense GPLv3+''')
    return 1
  
  if options.days <= 0:
    parser.error('Can not work with negative or zero days')

  if options.stat and options.quiet:
    parser.error('Specifying both --quiet and --stat does not make sense')

  if options.verbose and options.quiet:
    parser.error('Specifying both --quiet and --verbose does not make sense')

  
  trash_info_path = os.path.expanduser(os.path.join(options.trash_path,'info'))
  if not os.path.exists(trash_info_path):
    logging.error('Can not find trash information directory. Make sure you have at least GNOME 2.24')
    logging.error('I was looking at: %s', trash_info_path)
    return 1
  
  total_size = 0
  total_files = 0
  deleted_size = 0
  deleted_files = 0
  for file_name in glob.iglob(os.path.join(trash_info_path, '*.trashinfo')):
    file_size = 0
    real_file = real_file_name(file_name)
    if options.check:
      if not os.path.exists(real_file):
        logging.warning('%s has no real file associated with it', file_name)
    if options.stat:
      # calculating file size is relatively expensive; only do it if needed
      file_size += get_consumed_size(file_name)
      if os.path.exists(real_file):
        if os.path.isdir(real_file):
          logging.log(VERBOSE, 'Calculating size of directory %s (might take a long time)', real_file)
        file_size += get_consumed_size(real_file)
    total_size += file_size
    total_files += 1
    file_time = trash_info_date(file_name)
    if file_time == None:
      continue
    #Calculate seconds from now
    seconds_old = time.time() - time.mktime(file_time)
    days_old = int(math.floor(seconds_old/(3600.0*24.0)))
    logging.log(VERBOSE, 'File %s', file_name)
    logging.log(VERBOSE, '  is %d days old, %d seconds, so it should %sbe removed', days_old, seconds_old, ['not ',''][int(days_old > options.days)])
    logging.log(VERBOSE, '  deletion date was %s', time.strftime('%c', file_time))
    if options.stat:
      logging.log(VERBOSE, '  consumes %s', fmt_bytes(file_size))
    if days_old > options.days:
      purge(options.trash_path, file_name, options.dryrun)
      deleted_size += file_size
      deleted_files += 1
  if options.stat:
    logging.info('Trash statistics:')
    logging.info('  %6d entries at start (%s)', total_files, fmt_bytes(total_size))
    logging.info(' -%6d deleted (%s)', deleted_files, fmt_bytes(deleted_size))
    logging.info(' =%6d remaining (%s)', (total_files - deleted_files), fmt_bytes(total_size - deleted_size))
  return 0

if __name__ == '__main__':
  sys.exit(main(sys.argv))
